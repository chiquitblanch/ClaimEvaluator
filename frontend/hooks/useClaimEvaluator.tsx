"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/../backend/deployments directory to retrieve 
  deployment information for ClaimEvaluator.sol:
  
  - <root>/abi/ClaimEvaluatorABI.ts
  - <root>/abi/ClaimEvaluatorAddresses.ts
*/
import { ClaimEvaluatorAddresses } from "@/abi/ClaimEvaluatorAddresses";
import { ClaimEvaluatorABI } from "@/abi/ClaimEvaluatorABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type ClaimEvaluatorInfoType = {
  abi: typeof ClaimEvaluatorABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves ClaimEvaluator contract metadata for the given EVM `chainId`.
 */
function getClaimEvaluatorByChainId(
  chainId: number | undefined
): ClaimEvaluatorInfoType {
  if (!chainId) {
    return { abi: ClaimEvaluatorABI.abi };
  }

  const entry =
    ClaimEvaluatorAddresses[chainId.toString() as keyof typeof ClaimEvaluatorAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: ClaimEvaluatorABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: ClaimEvaluatorABI.abi,
  };
}

export const useClaimEvaluator = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // States
  const [currentClaimId, setCurrentClaimId] = useState<number | undefined>(undefined);
  const [lossAmountHandle, setLossAmountHandle] = useState<string | undefined>(undefined);
  const [riskLevelHandle, setRiskLevelHandle] = useState<string | undefined>(undefined);
  const [payoutHandle, setPayoutHandle] = useState<string | undefined>(undefined);
  
  const [clearLossAmount, setClearLossAmount] = useState<ClearValueType | undefined>(undefined);
  const [clearRiskLevel, setClearRiskLevel] = useState<ClearValueType | undefined>(undefined);
  const [clearPayout, setClearPayout] = useState<ClearValueType | undefined>(undefined);
  
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isEvaluating, setIsEvaluating] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const claimEvaluatorRef = useRef<ClaimEvaluatorInfoType | undefined>(undefined);
  const isSubmittingRef = useRef<boolean>(false);
  const isEvaluatingRef = useRef<boolean>(false);
  const isDecryptingRef = useRef<boolean>(false);
  const isRefreshingRef = useRef<boolean>(false);

  // ClaimEvaluator contract info
  const claimEvaluator = useMemo(() => {
    const c = getClaimEvaluatorByChainId(chainId);
    claimEvaluatorRef.current = c;
    // 仅当 chainId 已知且该网络未配置合约地址时才提示未部署的信息
    // 当 chainId 未定义或已有地址时不再提示，防止误报
    if (chainId !== undefined && !c.address) {
      setMessage(`ClaimEvaluator deployment not found for chainId=${chainId}.`);
    } else if (chainId === undefined || c.address) {
      // 当 chainId 未定义或已有地址时，清除之前的错误消息
      setMessage("");
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!claimEvaluator) {
      return undefined;
    }
    // 当 chainId 未定义时，返回 undefined 而不是 false，避免误报
    if (chainId === undefined) {
      return undefined;
    }
    return (Boolean(claimEvaluator.address) && claimEvaluator.address !== ethers.ZeroAddress);
  }, [claimEvaluator, chainId]);

  // Submit claim
  const canSubmitClaim = useMemo(() => {
    return claimEvaluator.address && instance && ethersSigner && !isSubmitting && !isEvaluating;
  }, [claimEvaluator.address, instance, ethersSigner, isSubmitting, isEvaluating]);

  const submitClaim = useCallback(
    (lossAmount: number, riskLevel: number) => {
      if (isSubmittingRef.current || isEvaluatingRef.current) {
        return;
      }

      if (!claimEvaluator.address || !instance || !ethersSigner) {
        return;
      }

      if (riskLevel < 1 || riskLevel > 3) {
        setMessage("Risk level must be between 1 (Low) and 3 (High)");
        return;
      }

      const thisChainId = chainId;
      const thisContractAddress = claimEvaluator.address;
      const thisEthersSigner = ethersSigner;

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage("Starting claim submission...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisContractAddress !== claimEvaluatorRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisContractAddress,
            thisEthersSigner.address
          );
          input.add32(lossAmount);
          input.add32(riskLevel);

          setMessage("Encrypting claim data...");
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore claim submission");
            return;
          }

          setMessage("Submitting claim to contract...");
          const contract = new ethers.Contract(
            thisContractAddress,
            claimEvaluator.abi,
            thisEthersSigner
          );

          const tx: ethers.TransactionResponse = await contract.submitClaim(
            enc.handles[0], // lossAmount
            enc.handles[1], // riskLevel
            enc.inputProof
          );

          setMessage(`Waiting for tx: ${tx.hash}...`);
          const receipt = await tx.wait();

          if (isStale()) {
            setMessage("Ignore claim submission");
            return;
          }

          // Parse the event to get claimId
          const claimSubmittedEvent = receipt?.logs.find((log: ethers.Log) => {
            try {
              const parsed = contract.interface.parseLog(log);
              return parsed?.name === "ClaimSubmitted";
            } catch {
              return false;
            }
          });

          if (claimSubmittedEvent) {
            const parsed = contract.interface.parseLog(claimSubmittedEvent);
            const claimId = parsed?.args[0];
            setCurrentClaimId(Number(claimId));
            setMessage(`Claim submitted successfully! Claim ID: ${claimId}`);
          } else {
            setMessage("Claim submitted but could not retrieve claim ID");
          }

          // Refresh claim data
          if (currentClaimId !== undefined) {
            refreshClaimData();
          }
        } catch (e) {
          setMessage(`Claim submission failed: ${e instanceof Error ? e.message : String(e)}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      claimEvaluator.address,
      claimEvaluator.abi,
      instance,
      chainId,
      sameChain,
      sameSigner,
      currentClaimId,
    ]
  );

  // Evaluate claim
  const canEvaluateClaim = useMemo(() => {
    return (
      claimEvaluator.address &&
      instance &&
      ethersSigner &&
      currentClaimId !== undefined &&
      !isSubmitting &&
      !isEvaluating
    );
  }, [claimEvaluator.address, instance, ethersSigner, currentClaimId, isSubmitting, isEvaluating]);

  const evaluateClaim = useCallback(() => {
    if (isSubmittingRef.current || isEvaluatingRef.current) {
      return;
    }

    if (!claimEvaluator.address || !instance || !ethersSigner || currentClaimId === undefined) {
      return;
    }

    const thisChainId = chainId;
    const thisContractAddress = claimEvaluator.address;
    const thisEthersSigner = ethersSigner;
    const thisClaimId = currentClaimId;

    isEvaluatingRef.current = true;
    setIsEvaluating(true);
    setMessage("Evaluating claim...");

    const run = async () => {
      const isStale = () =>
        thisContractAddress !== claimEvaluatorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const contract = new ethers.Contract(
          thisContractAddress,
          claimEvaluator.abi,
          thisEthersSigner
        );

        setMessage(`Calling evaluateClaim for claim ID ${thisClaimId}...`);
        const tx: ethers.TransactionResponse = await contract.evaluateClaim(thisClaimId);

        setMessage(`Waiting for tx: ${tx.hash}...`);
        const receipt = await tx.wait();

        if (isStale()) {
          setMessage("Ignore claim evaluation");
          return;
        }

        setMessage(`Claim evaluated successfully! Status: ${receipt?.status}`);
        
        // Refresh claim data
        refreshClaimData();
      } catch (e) {
        setMessage(`Claim evaluation failed: ${e instanceof Error ? e.message : String(e)}`);
      } finally {
        isEvaluatingRef.current = false;
        setIsEvaluating(false);
      }
    };

    run();
  }, [
    ethersSigner,
    claimEvaluator.address,
    claimEvaluator.abi,
    instance,
    chainId,
    currentClaimId,
    sameChain,
    sameSigner,
  ]);

  // Refresh claim data
  const canRefresh = useMemo(() => {
    return claimEvaluator.address && ethersReadonlyProvider && !isRefreshing && currentClaimId !== undefined;
  }, [claimEvaluator.address, ethersReadonlyProvider, isRefreshing, currentClaimId]);

  const refreshClaimData = useCallback(() => {
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !claimEvaluatorRef.current ||
      !claimEvaluatorRef.current?.chainId ||
      !claimEvaluatorRef.current?.address ||
      !ethersReadonlyProvider ||
      currentClaimId === undefined
    ) {
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = claimEvaluatorRef.current.chainId;
    const thisContractAddress = claimEvaluatorRef.current.address;
    const thisClaimId = currentClaimId;

    const contract = new ethers.Contract(
      thisContractAddress,
      claimEvaluatorRef.current.abi,
      ethersReadonlyProvider
    );

    Promise.all([
      contract.getLossAmount(thisClaimId),
      contract.getRiskLevel(thisClaimId),
      contract.getPayout(thisClaimId),
    ])
      .then(([lossAmount, riskLevel, payout]) => {
        if (
          sameChain.current(thisChainId) &&
          thisContractAddress === claimEvaluatorRef.current?.address &&
          thisClaimId === currentClaimId
        ) {
          setLossAmountHandle(lossAmount);
          setRiskLevelHandle(riskLevel);
          setPayoutHandle(payout);
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage(`Failed to refresh claim data: ${e instanceof Error ? e.message : String(e)}`);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain, currentClaimId]);

  // Auto refresh when claimId changes
  useEffect(() => {
    if (currentClaimId !== undefined) {
      refreshClaimData();
    }
  }, [currentClaimId, refreshClaimData]);

  // Decrypt payout
  const canDecryptPayout = useMemo(() => {
    return (
      claimEvaluator.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      payoutHandle &&
      payoutHandle !== ethers.ZeroHash &&
      payoutHandle !== clearPayout?.handle
    );
  }, [
    claimEvaluator.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    payoutHandle,
    clearPayout,
  ]);

  const decryptPayout = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!claimEvaluator.address || !instance || !ethersSigner) {
      return;
    }

    if (payoutHandle === clearPayout?.handle) {
      return;
    }

    if (!payoutHandle || payoutHandle === ethers.ZeroHash) {
      setClearPayout(undefined);
      return;
    }

    const thisChainId = chainId;
    const thisContractAddress = claimEvaluator.address;
    const thisPayoutHandle = payoutHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Starting decryption...");

    const run = async () => {
      const isStale = () =>
        thisContractAddress !== claimEvaluatorRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [claimEvaluator.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Decrypting payout...");

        const res = await instance.userDecrypt(
          [{ handle: thisPayoutHandle, contractAddress: thisContractAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("Decryption completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        const resRecord = res as Record<string, string | bigint | boolean>;
        setClearPayout({ handle: thisPayoutHandle, clear: resRecord[thisPayoutHandle] });
        setMessage(`Payout amount: ${resRecord[thisPayoutHandle]}`);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    claimEvaluator.address,
    instance,
    payoutHandle,
    chainId,
    sameChain,
    sameSigner,
    clearPayout,
  ]);

  return {
    contractAddress: claimEvaluator.address,
    isDeployed,
    canSubmitClaim,
    canEvaluateClaim,
    canRefresh,
    canDecryptPayout,
    submitClaim,
    evaluateClaim,
    refreshClaimData,
    decryptPayout,
    currentClaimId,
    lossAmountHandle,
    riskLevelHandle,
    payoutHandle,
    clearPayout: clearPayout?.clear,
    isSubmitting,
    isEvaluating,
    isRefreshing,
    isDecrypting,
    message,
  };
};

